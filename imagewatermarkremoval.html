<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Watermark Removal - Before and After</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/2.1.2/tesseract.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background-color: #f4f4f4;
    }
    #image-input {
      margin-bottom: 20px;
    }
    .controls {
      margin-top: 10px;
    }
    .controls button {
      margin-right: 10px;
    }
    #original-container, #modified-container {
      display: inline-block;
      width: 48%;
      vertical-align: top;
    }
    canvas {
      border: 1px solid #ccc;
      margin-top: 10px;
    }
  </style>
</head>
<body>

<h1>Watermark Removal - Before and After</h1>
<p>Upload an image, automatically detect any watermark, remove it, and see the difference between the original and modified image.</p>

<input type="file" id="image-input" accept="image/*">
<div id="image-info"></div>

<!-- Containers for Original and Modified Image -->
<div id="original-container">
  <h3>Original Image</h3>
  <canvas id="original-canvas" width="400" height="300"></canvas>
</div>
<div id="modified-container">
  <h3>Modified Image</h3>
  <canvas id="modified-canvas" width="400" height="300"></canvas>
</div>

<div class="controls">
  <button id="remove-watermark">Remove Watermark</button>
</div>

<script>
  let imageElement, detectedTextRegions = [];
  let originalImageData, ctxOriginal, ctxModified;

  document.getElementById('image-input').addEventListener('change', handleImageUpload);

  function handleImageUpload(event) {
    const file = event.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
          imageElement = img;
          document.getElementById('image-info').innerHTML = 'Image loaded. Ready to detect watermark.';

          // Display the original image
          const originalCanvas = document.getElementById('original-canvas');
          ctxOriginal = originalCanvas.getContext('2d');
          ctxOriginal.clearRect(0, 0, originalCanvas.width, originalCanvas.height);
          ctxOriginal.drawImage(img, 0, 0, originalCanvas.width, originalCanvas.height);

          // Store original image data for reference
          originalImageData = ctxOriginal.getImageData(0, 0, originalCanvas.width, originalCanvas.height);

          // Initialize modified canvas
          const modifiedCanvas = document.getElementById('modified-canvas');
          ctxModified = modifiedCanvas.getContext('2d');
          ctxModified.clearRect(0, 0, modifiedCanvas.width, modifiedCanvas.height);
          ctxModified.drawImage(img, 0, 0, modifiedCanvas.width, modifiedCanvas.height);

          detectTextAndRemove(img);
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }
  }

  // Detect watermark using Tesseract.js
  function detectTextAndRemove(img) {
    Tesseract.recognize(
      img,
      'eng',
      {
        logger: (m) => console.log(m)
      }
    ).then(({ data: { text, blocks } }) => {
      console.log("Detected Text: ", text);
      if (blocks) {
        detectedTextRegions = blocks.map(block => block.bbox);
        alert("Watermark detected, click 'Remove Watermark' to proceed.");
      } else {
        alert("No text watermark detected.");
      }
    });
  }

  // Remove watermark and rebuild the image
  document.getElementById('remove-watermark').addEventListener('click', () => {
    if (detectedTextRegions.length > 0) {
      detectedTextRegions.forEach(region => {
        rebuildRegion(region);
      });
      alert("Watermark removed. See the comparison.");
    } else {
      alert("No watermark detected to remove.");
    }
  });

  // Rebuild the image by replacing the watermark area
  function rebuildRegion(region) {
    const width = region.width;
    const height = region.height;
    const x = region.x;
    const y = region.y;

    // Get the surrounding pixels to fill in the watermark area
    const surroundingPixels = getSurroundingPixels(x, y, width, height);

    // Rebuild the region by setting the surrounding pixels
    for (let i = 0; i < width; i++) {
      for (let j = 0; j < height; j++) {
        const pixelIndex = ((y + j) * originalImageData.width + (x + i)) * 4;
        originalImageData.data[pixelIndex] = surroundingPixels[i][j].r;
        originalImageData.data[pixelIndex + 1] = surroundingPixels[i][j].g;
        originalImageData.data[pixelIndex + 2] = surroundingPixels[i][j].b;
        originalImageData.data[pixelIndex + 3] = 255; // Fully opaque
      }
    }

    // Redraw the modified image
    ctxModified.putImageData(originalImageData, 0, 0);
  }

  // Get the surrounding pixels to fill in the region
  function getSurroundingPixels(x, y, width, height) {
    let pixels = [];

    // Collect surrounding pixels by averaging adjacent areas
    for (let i = 0; i < width; i++) {
      pixels[i] = [];
      for (let j = 0; j < height; j++) {
        // Get average color of surrounding pixels (just an example, you can improve this)
        const px = (x + i);
        const py = (y + j);
        const pixelIndex = (py * originalImageData.width + px) * 4;

        // Get the surrounding pixel color
        const r = originalImageData.data[pixelIndex];
        const g = originalImageData.data[pixelIndex + 1];
        const b = originalImageData.data[pixelIndex + 2];

        pixels[i][j] = { r, g, b };
      }
    }

    return pixels;
  }
</script>

</body>
</html>
